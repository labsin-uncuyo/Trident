from __future__ import annotations

import json
import os
import threading
import time
from pathlib import Path
from typing import Dict

from fastapi import FastAPI, HTTPException

RUN_ID = os.getenv("RUN_ID", "run_local")
DEFENDER_PORT = int(os.getenv("DEFENDER_PORT", "8000"))
ALERT_FILE = Path("/outputs") / RUN_ID / "defender_alerts.ndjson"
_LOCK = threading.Lock()

app = FastAPI()


@app.get("/health")
async def health() -> Dict[str, str]:
    return {"status": "ok", "run_id": RUN_ID, "timestamp": str(time.time())}


@app.post("/alerts")
async def alerts(alert: Dict[str, object]) -> Dict[str, object]:
    enriched = dict(alert)
    enriched.setdefault("run_id", RUN_ID)
    enriched.setdefault("timestamp", time.time())
    line = json.dumps(enriched)
    try:
        with _LOCK:
            ALERT_FILE.parent.mkdir(parents=True, exist_ok=True)
            with ALERT_FILE.open("a", encoding="utf-8") as handle:
                handle.write(line + "\n")
    except OSError as exc:
        raise HTTPException(status_code=500, detail="failed to persist alert") from exc
    return {"status": "stored", "run_id": RUN_ID}
