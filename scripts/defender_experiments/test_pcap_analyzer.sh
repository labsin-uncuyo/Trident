#!/bin/bash

# Individual Feature Test Script for PCAP Analyzer
# Tests the pcap analyzer with controlled individual scenarios
# Uses same structure as run_experiment.sh but focuses on individual features

set -e

# Configuration
TEST_ID="${1:-$(date +%s)}"
LAB_PASSWORD="${LAB_PASSWORD:-admin123}"
PCAP_ROTATE_SECS="${PCAP_ROTATE_SECS:-30}"
SLIPS_PROCESS_ACTIVE="${SLIPS_PROCESS_ACTIVE:-1}"
SLIPS_WATCH_INTERVAL="${SLIPS_WATCH_INTERVAL:-1}"
DEFENDER_PORT="${DEFENDER_PORT:-8000}"

# Paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
OUTPUTS_DIR="$PROJECT_ROOT/outputs"
TEST_OUTPUTS="$OUTPUTS_DIR/test_${TEST_ID}"
RUN_ID_FILE="$PROJECT_ROOT/outputs/.current_run"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging
log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS:${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1"
}

log_error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1"
}

# Check if required tools are available
check_prerequisites() {
    log "Checking prerequisites..."

    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed or not in PATH"
        exit 1
    fi

    if ! command -v make &> /dev/null; then
        log_error "Make is not installed or not in PATH"
        exit 1
    fi

    if ! command -v python3 &> /dev/null; then
        log_error "Python3 is not installed or not in PATH"
        exit 1
    fi

    if [[ ! -f "$PROJECT_ROOT/Makefile" ]]; then
        log_error "Makefile not found: $PROJECT_ROOT/Makefile"
        exit 1
    fi

    log_success "Prerequisites check passed"
}

# Clean up any existing containers and networks
cleanup() {
    log "Cleaning up existing containers..."

    # Use main Makefile to clean up
    cd "$PROJECT_ROOT"
    make down || true

    # Wait for containers to fully stop
    sleep 5

    log_success "Cleanup completed"
}

# Set up test environment
setup_environment() {
    log "Setting up test environment for ID: test_$TEST_ID"

    # Create outputs directory structure for individual tests
    mkdir -p "$TEST_OUTPUTS"/{test_{1..6}/pcaps,slips_output,logs}

    # Set RUN_ID in the Makefile's run ID file
    echo "test_$TEST_ID" > "$RUN_ID_FILE"

    # Create .env file if it doesn't exist
    if [[ ! -f "$PROJECT_ROOT/.env" ]]; then
        log "Creating .env file with default values..."
        cat > "$PROJECT_ROOT/.env" << EOF
# Generated by test_pcap_analyzer.sh
RUN_ID=test_$TEST_ID
LAB_PASSWORD=$LAB_PASSWORD
PCAP_ROTATE_SECS=$PCAP_ROTATE_SECS
SLIPS_PROCESS_ACTIVE=$SLIPS_PROCESS_ACTIVE
SLIPS_WATCH_INTERVAL=$SLIPS_WATCH_INTERVAL
DEFENDER_PORT=$DEFENDER_PORT
EOF
    else
        log "Updating .env file with test ID..."
        sed -i "s/^RUN_ID=.*/RUN_ID=test_$TEST_ID/" "$PROJECT_ROOT/.env"
    fi

    log_success "Environment setup completed"
}

# Start the lab infrastructure
start_infrastructure() {
    log "Starting lab infrastructure using main Makefile..."

    cd "$PROJECT_ROOT"

    # Export environment variables
    export RUN_ID="test_$TEST_ID"
    export LAB_PASSWORD="$LAB_PASSWORD"
    export PCAP_ROTATE_SECS="$PCAP_ROTATE_SECS"
    export SLIPS_PROCESS_ACTIVE="$SLIPS_PROCESS_ACTIVE"
    export SLIPS_WATCH_INTERVAL="$SLIPS_WATCH_INTERVAL"
    export DEFENDER_PORT="$DEFENDER_PORT"

    # Start services using make up
    make up

    log_success "Infrastructure startup initiated"
}

# Wait for services to be healthy
wait_for_services() {
    log "Waiting for services to become healthy..."

    cd "$PROJECT_ROOT"

    # Use the make verify command which includes health checks
    if make verify; then
        log_success "All services are healthy!"
        return 0
    else
        log_error "Services failed health checks"
        return 1
    fi
}

# Clear existing PCAP files before each test
clear_pcaps() {
    log "Clearing existing PCAP files..."
    rm -f "$TEST_OUTPUTS/pcaps/"*.pcap 2>/dev/null || true
    sleep 2
}

# Copy current PCAPs to specific test folder
copy_pcaps_to_test() {
    local test_num=$1
    log "Copying PCAPs to Test $test_num folder..."

    if [[ -d "$TEST_OUTPUTS/pcaps" ]]; then
        local pcap_count=$(find "$TEST_OUTPUTS/pcaps" -name "*.pcap" | wc -l)
        if [[ $pcap_count -gt 0 ]]; then
            cp "$TEST_OUTPUTS/pcaps/"*.pcap "$TEST_OUTPUTS/test_$test_num/pcaps/" 2>/dev/null || true
            log "Copied $pcap_count PCAP files to Test $test_num"
        else
            log_warning "No PCAP files found to copy for Test $test_num"
        fi
    fi
}

# Generate test PCAP files for individual features
generate_test_pcaps() {
    log "Generating controlled test PCAP files for individual features..."

    # Test 1: Network scanning only (no successful responses)
    log "Test 1: Network scanning (no responses)"
    clear_pcaps
    docker exec lab_compromised timeout 30 bash -c "
        # Scan non-existent IPs to avoid server responses
        for ip in 172.31.0.11 172.31.0.12 172.31.0.13 172.31.0.14; do
            ping -c 1 -W 1 \$ip 2>/dev/null &
        done
        wait
        sleep 3
    " || true
    sleep 3
    copy_pcaps_to_test 1

    # Wait 15 seconds for traffic capture (PCAP rotation is 30s)
    sleep 15

    # Test 2: Server discovery (ping to actual server)
    log "Test 2: Server discovery (ping successful)"
    clear_pcaps
    docker exec lab_compromised timeout 30 bash -c "
        ping -c 3 172.31.0.10
        sleep 3
    " || true
    sleep 3
    copy_pcaps_to_test 2

    # Wait 15 seconds for traffic capture (PCAP rotation is 30s)
    sleep 15

    # Test 3: SSH port discovery (port scan without SSH handshake)
    log "Test 3: SSH port discovery (port scan only)"
    clear_pcaps
    docker exec lab_compromised timeout 30 bash -c "
        # Install nmap if not available
        which nmap >/dev/null || apt-get update -qq && apt-get install -y nmap >/dev/null 2>&1
        # Scan port 22 to generate SYN packets
        nmap -p 22 -sS -Pn 172.31.0.10
        sleep 3
    " || true
    sleep 3
    copy_pcaps_to_test 3

    # Wait 15 seconds for traffic capture (PCAP rotation is 30s)
    sleep 15

    # Test 4: SSH handshake without authentication
    log "Test 4: SSH handshake (connection without auth)"
    clear_pcaps
    docker exec lab_compromised timeout 30 bash -c "
        # Install required tools
        apt-get update -qq >/dev/null 2>&1
        apt-get install -y -qq openssh-client >/dev/null 2>&1

        # Start SSH connection but timeout before authentication completes
        timeout 3 ssh -o ConnectTimeout=2 -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no admin@172.31.0.10 || true
        sleep 3
    " || true
    sleep 3
    copy_pcaps_to_test 4

    # Wait 15 seconds for traffic capture (PCAP rotation is 30s)
    sleep 15

    # Test 5: SSH authentication attempts (wrong password)
    log "Test 5: SSH authentication attempts (wrong password)"
    clear_pcaps
    docker exec lab_compromised timeout 30 bash -c "
        # Install required tools (same as attack_script.sh)
        apt-get update -qq >/dev/null 2>&1
        apt-get install -y -qq openssh-client sshpass >/dev/null 2>&1

        # Try SSH with wrong passwords (same approach as attack_script.sh)
        for password in 'wrongpass123' 'admin' 'password' '123456'; do
            timeout 5 sshpass -p \"\$password\" ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no admin@172.31.0.10 'echo test' >/dev/null 2>&1 || true
            sleep 1
        done
        sleep 3
    " || true
    sleep 3
    copy_pcaps_to_test 5

    # Wait 30 seconds for traffic capture (PCAP rotation is 300s)
    sleep 30

    # Test 6: Successful SSH authentication (correct password)
    log "Test 6: Successful SSH authentication (correct password)"
    clear_pcaps

    # Record start time for this test
    local test6_start_time=$(date +%s)

    docker exec lab_compromised timeout 30 bash -c "
        # Install required tools (same as attack_script.sh)
        apt-get update -qq >/dev/null 2>&1
        apt-get install -y -qq openssh-client sshpass >/dev/null 2>&1

        # Connect with correct password and generate sustained traffic to meet strict criteria
        timeout 15 sshpass -p '$LAB_PASSWORD' ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no admin@172.31.0.10 '
            echo \"Successfully authenticated\"
            whoami
            pwd
            ls -la
            # Generate sustained traffic for 6+ seconds to meet analyzer criteria
            for i in {1..10}; do
                echo \"Command \$i: \$(date)\"
                cat /etc/hostname
                sleep 1
            done
            echo \"SSH session complete\"
        ' || true
        sleep 3
    " || true
    sleep 3

    # Wait longer for Test 6 to ensure complete SSH session is captured
    log "Waiting 30 seconds to ensure complete SSH session is captured in PCAPs..."
    sleep 30

    copy_pcaps_to_test 6

    log_success "Test PCAP generation completed"
}

# Analyze individual test results
analyze_test_results() {
    log "Analyzing individual test results..."

    # Use virtual environment python if available, otherwise system python3.12
    if [[ -f "$PROJECT_ROOT/.venv/bin/python" ]]; then
        PYTHON_CMD="$PROJECT_ROOT/.venv/bin/python"
        log "Using virtual environment Python: $PYTHON_CMD"
    else
        PYTHON_CMD="python3.12"
        log "Using system Python: python3.12"
    fi

    local analyze_script="$SCRIPT_DIR/analyze_pcaps.py"
    if [[ ! -f "$analyze_script" ]]; then
        log_error "PCAP analysis script not found: $analyze_script"
        return 1
    fi

    # Expected results for each test (fixed based on corrected IP configuration)
    declare -A expected_results=(
        [1]="Network Scanning Only|Server Contacted, No Response"  # Scanning non-existent IPs
        [2]="Server Found, No SSH|Passive - Server Discovered"    # Ping to server
        [3]="SSH Port Found, No Connection|Alert - SSH Port Scanned"  # Port scan of SSH
        [4]="SSH Auth Attempted|Critical - SSH Brute Force Detected"  # SSH handshake
        [5]="SSH Auth Attempted|Critical - SSH Brute Force Detected"  # Failed auth attempts
        [6]="SSH Auth Success|FAILURE - Attack Successful"         # Successful authentication
    )

    # Run analysis for each test
    for i in {1..6}; do
        log "Analyzing Test $i..."

        if [[ -d "$TEST_OUTPUTS/test_$i/pcaps" ]]; then
            local pcap_count=$(find "$TEST_OUTPUTS/test_$i/pcaps" -name "*.pcap" | wc -l)
            if [[ $pcap_count -gt 0 ]]; then
                log "Found $pcap_count PCAP files for Test $i"

                "$PYTHON_CMD" "$analyze_script" "$TEST_OUTPUTS/test_$i/pcaps" --output "$TEST_OUTPUTS/test_$i/analysis.json"

                if [[ $? -eq 0 ]]; then
                    log_success "Test $i analysis completed"

                    # Read and display results using Python instead of jq
                    if [[ -f "$TEST_OUTPUTS/test_$i/analysis.json" ]]; then
                        local status=$("$PYTHON_CMD" -c "
import json
try:
    with open('$TEST_OUTPUTS/test_$i/analysis.json', 'r') as f:
        data = json.load(f)
    print(data.get('status', 'Unknown'))
except:
    print('Unknown')
" 2>/dev/null || echo "Unknown")

                        local performance=$("$PYTHON_CMD" -c "
import json
try:
    with open('$TEST_OUTPUTS/test_$i/analysis.json', 'r') as f:
        data = json.load(f)
    print(data.get('defender_performance', 'Unknown'))
except:
    print('Unknown')
" 2>/dev/null || echo "Unknown")

                        echo "  Status: $status"
                        echo "  Performance: $performance"

                        # Check if result matches expected pattern
                        local expected="${expected_results[$i]}"
                        if [[ "$status" == *"$expected"* || "$performance" == *"$expected"* ]]; then
                            log_success "Test $i: Result matches expected pattern"
                        else
                            log_warning "Test $i: Unexpected result (expected: $expected)"
                        fi
                    fi
                else
                    log_error "Test $i analysis failed"
                fi
            else
                log_warning "No PCAP files found for Test $i"
            fi
        else
            log_warning "Test $i directory not found"
        fi
        echo "---"
    done
}

# Stop the infrastructure
stop_infrastructure() {
    log "Stopping infrastructure using main Makefile..."

    cd "$PROJECT_ROOT"
    make down

    log_success "Infrastructure stopped"
}

# Main execution function
run_feature_tests() {
    local start_time=$(date +%s)

    log "Starting PCAP analyzer feature tests - test_$TEST_ID"
    log "Start time: $(date)"

    # Clean up any existing environment using make down
    log "Cleaning up existing environment with make down..."
    cd "$PROJECT_ROOT"
    make down || log_warning "make down failed, continuing..."

    # Execute test phases
    check_prerequisites
    cleanup
    setup_environment
    start_infrastructure
    wait_for_services

    log "All services ready, starting feature tests in 10 seconds..."
    sleep 10

    generate_test_pcaps
    analyze_test_results
    stop_infrastructure

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    log_success "PCAP analyzer feature tests completed successfully!"
    log "Duration: ${duration}s"
    log "Results saved in: $TEST_OUTPUTS"

    # Create test summary
    cat > "$TEST_OUTPUTS/test_summary.json" << EOF
{
    "test_id": "test_$TEST_ID",
    "start_time": "$(date -d @$start_time -Iseconds)",
    "end_time": "$(date -d @$end_time -Iseconds)",
    "duration_seconds": $duration,
    "status": "completed",
    "tests_performed": [
        "Test 1: Network scanning (no responses)",
        "Test 2: Server discovery (ping successful)",
        "Test 3: SSH port discovery (port scan only)",
        "Test 4: SSH handshake (connection without auth)",
        "Test 5: SSH authentication attempts (wrong password)",
        "Test 6: Successful SSH authentication (correct password)"
    ]
}
EOF

    # Display final summary
    echo ""
    echo "=== PCAP ANALYZER FEATURE TEST SUMMARY ==="
    echo "Test ID: test_$TEST_ID"
    echo "Duration: ${duration}s"
    echo "Output directory: $TEST_OUTPUTS"
    echo ""
    echo "Individual test analyses:"
    for i in {1..6}; do
        if [[ -f "$TEST_OUTPUTS/test_$i/analysis.json" ]]; then
            local status=$("$PYTHON_CMD" -c "
import json
try:
    with open('$TEST_OUTPUTS/test_$i/analysis.json', 'r') as f:
        data = json.load(f)
    print(data.get('status', 'Unknown'))
except:
    print('Unknown')
" 2>/dev/null || echo "Unknown")
            echo "  Test $i: $status"
        fi
    done
}

# Handle script interruption
interrupt_handler() {
    log_warning "Feature tests interrupted! Cleaning up..."
    stop_infrastructure
    exit 1
}

# Set up interrupt handlers
trap interrupt_handler INT TERM

# Show usage
usage() {
    echo "Usage: $0 [TEST_ID]"
    echo "  TEST_ID: Optional unique identifier for the test (defaults to timestamp)"
    echo ""
    echo "Environment variables:"
    echo "  LAB_PASSWORD: SSH password for containers (default: admin123)"
    echo "  PCAP_ROTATE_SECS: PCAP rotation interval in seconds (default: 5)"
    echo "  SLIPS_PROCESS_ACTIVE: Enable SLIPS processing (default: 1)"
    echo "  SLIPS_WATCH_INTERVAL: SLIPS watch interval in seconds (default: 1)"
    echo "  DEFENDER_PORT: Defender API port (default: 8000)"
    exit 1
}

# Parse arguments
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    usage
fi

# Set default test ID if not provided
if [[ -z "$TEST_ID" ]]; then
    TEST_ID=$(date +%s)
fi

# Run the feature tests
run_feature_tests